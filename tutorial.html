
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Tutorial &#8212; Mininet-Optical  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Visualization" href="visualization.html" />
    <link rel="prev" title="API Overview" href="api-overview.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="tutorial">
<h1>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this heading">¶</a></h1>
<p>Mininet-Optical can be used in either pure simulation mode, without
a packet-optical dataplane and external control plane, or in full
emulation mode, with a usable packet-optical dataplane and external
SDN control plane.</p>
<p>The Simulation Tutorial explains how to use Mininet-Optical in pure
simulation mode, while the Emulation Tutorial explains how to use
Mininet-Optical in full emulation mode.</p>
<section id="simulation-mode-tutorial">
<h2>Simulation Mode Tutorial<a class="headerlink" href="#simulation-mode-tutorial" title="Permalink to this heading">¶</a></h2>
<p>Mininet-Optical’s simulation mode is useful when you just want to
simulate optical transmissions and don’t need to send actual data
through your network, model packet devices, or use an external
SDN controller.</p>
<p>You may find it to be convenient due to its fast startup and
ease of use in an IDE such as Pycharm. Since it doesn’t create
virtual network devices in Linux it does not require root privileges
to run.</p>
<p>After completing these exercises you will learn how to :</p>
<ul class="simple">
<li><p>add nodes and links to a network model.</p></li>
<li><p>install switch rules to the ROADM nodes.</p></li>
<li><p>simulate optical transmissions.</p></li>
<li><p>model a ring topology.</p></li>
</ul>
<p><em>Notes:</em></p>
<p><em>For exercises 1 and 2 you will need the tests/tutorial.py script.</em></p>
<p><em>You will be generating another script labeled: three_ring_topology.py
for exercise 3.</em></p>
<p><em>Hints:</em></p>
<p><em>If you get stuck with exercises 1 and 2, please refer to
tests/monitoring_gosnr_vs_power.py for hints.</em></p>
<p><em>If you get stuck with exercise 3, please refer to tests/ringtest.py</em></p>
<p><em>Bear in mind that neither of these scripts is the answer to the
exercises!</em></p>
<p><strong>Exercise 1.</strong> Add an extra LineTerminal and a ROADM node to the linear
topology (position indistinct, i.e., could be at the beginning, middle
or end of the topology), install the appropriate switch rules that will
enable the transmission of channels 1, 2 and 3 from LT1 —&gt; LT6.</p>
<p><strong>Exercise 2.</strong> Following ex. 1), monitor the OSNR and the gOSNR levels
of channel 2 at the output interface of every EDFA in the linear
topology (TX: LT1; RX: LT6). For the transmission, use launch power
levels: 0, 2 and 4 dBm.</p>
<p>If motivated enough, try to plot the sequence.</p>
<p><strong>Exercise 3.</strong> Create a ring topology with 3 ROADM nodes, transmit
channels 1, 2, 3 as follows:</p>
<p>channel 1 is transmitted by LT1 and is received at LT2.</p>
<p>channels 2 and 3 are transmitted by LT2 and are received at LT1.</p>
<p>Try and rearrange the transmission of channels to create loops. Is the
system catching them?</p>
<p>POSSIBLE OUTPUTS FROM THE EXERCISES:</p>
<p><strong>Exercise 2</strong>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*** Monitoring channel with index: 2
*** Building Linear network topology for operational power: 0
*** Monitoring interfaces
*** Destroying objects
*** Building Linear network topology for operational power: 2
*** Monitoring interfaces
*** Destroying objects
*** Building Linear network topology for operational power: 4
*** Monitoring interfaces
*** Destroying objects

The OSNR of Channel 2 at every EDFA location for launch power 4.00 dBm:
[31.502684964557986, 28.176061337796398, 26.314628272797336,
25.015839898466922, 24.13611249709385, 23.304363233906848,
22.60659223643803, 22.00556583390794, 21.543462282662198,
21.06605464395392, 20.635968107119602, 20.244661874079043,
19.931195226498627, 19.596307147424525, 19.28540409149395,
18.99527882336643, 18.758083090421028, 18.50016560987458,
18.25671038540936, 18.026181282510155]

The OSNR of Channel 2 at every EDFA location for launch power 2.00 dBm:
[33.50268137427075, 30.176059668755695, 28.31462718556177,
27.01583909226315, 26.13611183872073, 25.304362690284655,
24.606591773502963, 24.00556543080363, 23.543461920246425,
23.06605431926585, 22.635967813044893, 22.244661605342294,
21.931194976475382, 21.596306915956195, 21.285403876016776,
20.995278621813668, 20.75808289958113, 20.500165430038248,
20.25671021537687, 20.026181121267854]

The OSNR of Channel 2 at every EDFA location for launch power 0.00 dBm:
[35.502675684055035, 32.176057023505756, 30.314625462410078,
29.01583781451658, 28.13611079526985, 27.304361828701694,
26.60659103980043, 26.00556479192643, 25.543461345856198,
25.06605380467, 24.635967346967934, 24.244661179423296,
23.931194580215273, 23.596306549103637, 23.285403534508482,
22.99527830237409, 22.758082597120293, 22.500165145016886,
22.256709945893554, 22.026180865716036]
</pre></div>
</div>
<p>Plotting the values:</p>
<p><img alt="" src="_images/Picture1.svg" /></p>
<figcaption>Figure. Output
</section>
<section id="emulation-tutorial">
<h2>Emulation Tutorial<a class="headerlink" href="#emulation-tutorial" title="Permalink to this heading">¶</a></h2>
<p>Mininet-Optical’s full emulation mode supports sending data
through the emulated network, supports modeling of packet devices
as well as optical devices, and supports external SDN control
of both packet and optical network elements.</p>
<p>Since emulation mode relies on Mininet (and Linux) to create
virtual network devices, it currently needs to run with root
privileges, and Python scripts are typically run using <code class="docutils literal notranslate"><span class="pre">sudo</span></code>.</p>
<p>For this exercise, you are going to modify the singleroadm.py script
to add additional transceivers and links, and then you are going to
configure the terminals (<code class="docutils literal notranslate"><span class="pre">t1</span></code>, <code class="docutils literal notranslate"><span class="pre">t2</span></code>, <code class="docutils literal notranslate"><span class="pre">t3</span></code>) and ROADM to enable
connectivity between all of the packet switches and hosts.</p>
<section id="part-0-make-sure-singleroadm-py-works-correctly">
<h3>Part 0: Make sure <code class="docutils literal notranslate"><span class="pre">singleroadm.py</span></code> works correctly<a class="headerlink" href="#part-0-make-sure-singleroadm-py-works-correctly" title="Permalink to this heading">¶</a></h3>
<p>First, make sure you can run <code class="docutils literal notranslate"><span class="pre">singleroadm.py</span></code>.</p>
<p>For example, you should be able to do something like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ sudo examples/simplelink.py
</pre></div>
</div>
<p>(or if that doesn’t work, <code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">PYTHONPATH=.</span> <span class="pre">python3</span> <span class="pre">examples/simplelink.py</span></code>)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*** Creating network
*** Adding controller
*** Adding hosts:
h1 h2 
*** Adding switches:
t1 t2 
*** Adding links:
(h1, t1) (h2, t2) (t1, t2) 
*** Configuring hosts
h1 h2 
*** Starting controller
c0 
*** Starting 2 switches
t1 t2 ...
...
mininet-optical&gt;
</pre></div>
</div>
<p>Then open up another terminal window on your VM (or machine where
mininet is running) and run the controller script, which will program
the ROADM to enable <code class="docutils literal notranslate"><span class="pre">h1</span></code> to talk to <code class="docutils literal notranslate"><span class="pre">h2</span></code> (but not <code class="docutils literal notranslate"><span class="pre">h3</span></code>!)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>$ cd ~/mininet-optical/
$ examples/config-singleroadm.sh
</pre></div>
</div>
<p>You should be able to see the REST calls that config-singleroadm.sh is
making as well as <code class="docutils literal notranslate"><span class="pre">OK</span></code> results to indicate they have succeeded. You should
also see monitoring data reported by the REST monitoring calls. The
ability to monitor power and OSNR is essential to SDN control of optical
networks.</p>
<p>In the Mininet window, you should see a number of successful signal
receptions. The osnr command should show signals received at <code class="docutils literal notranslate"><span class="pre">t1</span></code> and
<code class="docutils literal notranslate"><span class="pre">t2</span></code> but not <code class="docutils literal notranslate"><span class="pre">t3</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mininet-optical&gt; osnr
&lt;name: t1-monitor, component: t1, mode: in&gt;:
&lt;ch1:191.35THz&gt; OSNR: 34.70 dB gOSNR: 34.58 dB
&lt;name: t2-monitor, component: t2, mode: in&gt;:
&lt;ch1:191.35THz&gt; OSNR: 34.70 dB gOSNR: 34.58 dB
&lt;name: t3-monitor, component: t3, mode: in&gt;:
</pre></div>
</div>
<p>If you run the <code class="docutils literal notranslate"><span class="pre">pingall</span></code> command, you will see that <code class="docutils literal notranslate"><span class="pre">h1</span></code> and <code class="docutils literal notranslate"><span class="pre">h2</span></code> can
talk to each other, but <code class="docutils literal notranslate"><span class="pre">h3</span></code> cannot communicate with either <code class="docutils literal notranslate"><span class="pre">h1</span></code> or
<code class="docutils literal notranslate"><span class="pre">h2</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mininet-optical&gt; pingall
*** Ping: testing ping reachability
h1 -&gt; h2 X
h2 -&gt; h1 X
h3 -&gt; X X
*** Results: 66% dropped (2/6 received)
</pre></div>
</div>
<p>Note it is also possible to program this “y” topology so that <code class="docutils literal notranslate"><span class="pre">h1</span></code>
can talk to <code class="docutils literal notranslate"><span class="pre">h2</span></code> or <code class="docutils literal notranslate"><span class="pre">h3</span></code>, but not both at the same time!</p>
<p>In the next part of this exercise, you are going to modify the network
topology by adding additional transceivers and links, and then you are
going to program it to enable all of the endpoints to communicate.</p>
<p>For now, exit out of mininet-optical by using <code class="docutils literal notranslate"><span class="pre">exit</span></code> or control-D:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mininet-optical&gt; exit
*** Stopping 1 controllers
c0
*** Stopping 9 links
.........
*** Stopping 7 switches
r1 s1 s2 s3 t1 t2 t3
*** Stopping 3 hosts
h1 h2 h3
*** Done
</pre></div>
</div>
<section id="important-note-bidirectional-emulator-api">
<h4>Important Note: Bidirectional Emulator API<a class="headerlink" href="#important-note-bidirectional-emulator-api" title="Permalink to this heading">¶</a></h4>
<p>Although the underlying <em>simulation</em> API is unidirectional, the links,
devices, and API that we will be using for this <em>emulation</em> tutorial are
<strong>bidirectional</strong>! This usually means that establishing a path in one
direction will establish a return path in the opposite direction, on the
same channel. With this API there is no way to select different
send/receive paths or channels. Links are bidirectional and establish a
set of fiber spans and amplifiers going in each direction. This approach
simplifies topology specification as well as SDN control, and is well
suited to this tutorial, but in our demo we will want more flexibility
to model a unidirectional hardware network (this work is currently in
progress.)</p>
</section>
</section>
<section id="part-1-add-transceivers-and-links">
<h3>Part 1: Add transceivers and links<a class="headerlink" href="#part-1-add-transceivers-and-links" title="Permalink to this heading">¶</a></h3>
<p>The <a class="reference internal" href="api-overview.html"><span class="doc">API Overview</span></a> explains the <code class="docutils literal notranslate"><span class="pre">simplelink.py</span></code> script and the
basics of the Mininet-Optical topology API in emulation mode.</p>
<p>For this part, you will need to figure out how to add an additional
transceiver to each terminal, as well as an additional link from each
terminal to the ROADM.</p>
<p>In order for your SDN control plane (which for this exercise will
probably be a simple configuration script similar to
examples/config-singleroadm.sh) to operate properly, you will need to
know which ports are connected on each device. You can specify the port
numbers in the parameters of the <code class="docutils literal notranslate"><span class="pre">addLink()</span></code> method.</p>
<p>When you are done, there should be two 50km links from <code class="docutils literal notranslate"><span class="pre">t1</span></code>&lt;-&gt;<code class="docutils literal notranslate"><span class="pre">r1</span></code>, two
50km links from <code class="docutils literal notranslate"><span class="pre">t2</span></code>&lt;-&gt;<code class="docutils literal notranslate"><span class="pre">r1</span></code>, and two 1m links from <code class="docutils literal notranslate"><span class="pre">t3</span></code>&lt;-&gt;<code class="docutils literal notranslate"><span class="pre">r1</span></code>.</p>
<p>You can check your topology from the <code class="docutils literal notranslate"><span class="pre">mininet-optical&gt;</span></code> prompt using the
net command. When you are done with this part, it should look something
like this:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mininet-optical&gt; net
h1 h1-eth0:s1-eth1
h2 h2-eth0:s2-eth1
h3 h3-eth0:s3-eth1
r1 lo: r1-wdm1:t1-wdm1 r1-wdm2:t1-wdm2 r1-wdm3:t2-wdm1 r1-wdm4:t2-wdm2
r1-wdm5:t3-wdm1 r1-wdm6:t3-wdm2
s1 lo: s1-eth1:h1-eth0 s1-eth2:t1-eth3 s1-eth3:t1-eth4
s2 lo: s2-eth1:h2-eth0 s2-eth2:t2-eth3 s2-eth3:t2-eth4
s3 lo: s3-eth1:h3-eth0 s3-eth2:t3-eth3 s3-eth3:t3-eth4
t1 lo: t1-wdm1:r1-wdm1 t1-wdm2:r1-wdm2 t1-eth3:s1-eth2 t1-eth4:s1-eth3
t2 lo: t2-wdm1:r1-wdm3 t2-wdm2:r1-wdm4 t2-eth3:s2-eth2 t2-eth4:s2-eth3
t3 lo: t3-wdm1:r1-wdm5 t3-wdm2:r1-wdm6 t3-eth3:s3-eth2 t3-eth4:s3-eth3
c0
t1-monitor
t2-monitor
t3-monitor
</pre></div>
</div>
<p><em>Don’t dismiss this as incomprehensible garbage</em> – it is actually
telling you useful information! Specifically, it is telling you how each
node’s interfaces are connected. For example, you can see that ROADM <code class="docutils literal notranslate"><span class="pre">r1</span></code>
now has two links to each of the terminals <code class="docutils literal notranslate"><span class="pre">t1</span></code>-<code class="docutils literal notranslate"><span class="pre">t3</span></code>, for a total of 6
links. You can also see the type of the port (Ethernet or WDM) as well
as the port number. For example, <code class="docutils literal notranslate"><span class="pre">r1-wdm1</span></code> is WDM port 1 on ROADM r1.</p>
<p>You can also use the <code class="docutils literal notranslate"><span class="pre">spans</span></code> command, which prints out long links but
ignores links of &lt;100m. So, you should see the links from <code class="docutils literal notranslate"><span class="pre">t1</span></code> and
<code class="docutils literal notranslate"><span class="pre">t3</span></code> but not <code class="docutils literal notranslate"><span class="pre">t2</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mininet-optical&gt; spans

(r1-&gt;t1) &lt;boost 18.0dB&gt; &lt;1 25.0km&gt; &lt;r1-t1-amp1 5.5dB&gt; &lt;2
25.0km&gt; &lt;r1-t1-amp2 5.5dB&gt;
(r1-&gt;t1) &lt;boost 18.0dB&gt; &lt;5 25.0km&gt; &lt;r1-t1-amp1 5.5dB&gt; &lt;6
25.0km&gt; &lt;r1-t1-amp2 5.5dB&gt;
(r1-&gt;t3) &lt;boost 18.0dB&gt; &lt;13 25.0km&gt; &lt;r1-t3-amp1 5.5dB&gt; &lt;14
25.0km&gt; &lt;r1-t3-amp2 5.5dB&gt;
(r1-&gt;t3) &lt;boost 18.0dB&gt; &lt;17 25.0km&gt; &lt;r1-t3-amp1 5.5dB&gt; &lt;18
25.0km&gt; &lt;r1-t3-amp2 5.5dB&gt;
(t1-&gt;r1) &lt;3 25.0km&gt; &lt;t1-r1-amp1 5.5dB&gt; &lt;4 25.0km&gt; &lt;t1-r1-amp2
5.5dB&gt;
(t1-&gt;r1) &lt;7 25.0km&gt; &lt;t1-r1-amp1 5.5dB&gt; &lt;8 25.0km&gt; &lt;t1-r1-amp2
5.5dB&gt;
(t3-&gt;r1) &lt;15 25.0km&gt; &lt;t3-r1-amp1 5.5dB&gt; &lt;16 25.0km&gt; &lt;t3-r1-amp2
5.5dB&gt;
(t3-&gt;r1) &lt;19 25.0km&gt; &lt;t3-r1-amp1 5.5dB&gt; &lt;20 25.0km&gt; &lt;t3-r1-amp2
5.5dB&gt;
</pre></div>
</div>
<p>Note that the spans command shows the underlying physical spans (modeled
by the simulator) which are unidirectional. Note that the fiber links
don’t have names but they have numbers in order to disambiguate them.</p>
<p>You may also wish to try the <code class="docutils literal notranslate"><span class="pre">intfs</span></code> and <code class="docutils literal notranslate"><span class="pre">ports</span></code> commands.</p>
<p>If you have installed <code class="docutils literal notranslate"><span class="pre">pygraphviz</span></code> (e.g. via <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">depend</span></code> and/or
using <code class="docutils literal notranslate"><span class="pre">sudo</span> <span class="pre">apt</span> <span class="pre">install</span> <span class="pre">python3-pygraphviz</span></code>), you can use the
<code class="docutils literal notranslate"><span class="pre">plotNet()</span></code> function in <code class="docutils literal notranslate"><span class="pre">singleroadm.py</span></code> to save a plot of the topology to
<code class="docutils literal notranslate"><span class="pre">singleroadm.png</span></code>. Your revised topology should look something like
this:</p>
<p><img alt="" src="_images/Picture2.svg" /></p>
<figcaption>Figure. Single ROADM Network Topology
<p>Note that there are two links (each of which is bidirectional,
implemented as two sequences of fiber spans and amplifiers, going in
opposite directions) from each packet switch (<code class="docutils literal notranslate"><span class="pre">s1</span></code>) to its respective
Terminal (<code class="docutils literal notranslate"><span class="pre">t1</span></code>) and to the ROADM. You can also see the port numbers for
each side of each link. You may find this to be the easiest way to
understand your network at a glance and to identify port numbers for the
next part.</p>
</section>
<section id="part-2-programming-the-data-plane">
<h3>Part 2: Programming the Data Plane<a class="headerlink" href="#part-2-programming-the-data-plane" title="Permalink to this heading">¶</a></h3>
<p>Lastly, we need to program the data plane so that we have full
connectivity. In order to do this, all we need to do is enable
connectivity between two pairs of Terminals, such as (<code class="docutils literal notranslate"><span class="pre">t1</span></code>, <code class="docutils literal notranslate"><span class="pre">t2</span></code>) and
(<code class="docutils literal notranslate"><span class="pre">t2</span></code>, <code class="docutils literal notranslate"><span class="pre">t3</span></code>).</p>
<p><em>Question to think about: Why is connecting two pairs of terminals
sufficient to connect all of the hosts?</em></p>
<p>In fact, you do not actually want to create a <em>loop</em> among the packet
switches. Since we are using <code class="docutils literal notranslate"><span class="pre">OVSBridge</span></code> without spanning tree enabled,
creating a loop typically leads to undesirable behavior where packets
loop forever, usually rendering the network unusable or extremely slow
(the problem is exacerbated by flooding and by broadcast packets for ARP
and DHCP.) This is a common error in L2 Ethernet networks that is
frequently seen by Mininet users who (often) think it is an emulator bug
rather than realistic (but incorrectly configured) behavior!</p>
<p>You should be able to use the REST calls described in the tutorial,
and/or modify the existing <code class="docutils literal notranslate"><span class="pre">singleroadm.sh</span></code> script to program your
network.</p>
<p>When you are done, you should see a number of successful signal
connections at the terminals:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mininet-optical&gt; signals
r1 Inputs:
{1: [(&lt;ch1:191.35THz&gt;, 140362746465920)], 2: [(&lt;ch2:191.40THz&gt;,
140362746465728)], 3: [(&lt;ch1:191.35THz&gt;, 140362746797456)], 4:
[(&lt;ch2:191.40THz&gt;, 140362746797360)], 5: [(&lt;ch1:191.35THz&gt;,
140362746797312)], 6: [(&lt;ch2:191.40THz&gt;, 140362746794720)]}
r1 Outputs:
{1: [(&lt;ch1:191.35THz&gt;, 140362746797456)], 2: [(&lt;ch2:191.40THz&gt;,
140362746794720)], 3: [(&lt;ch1:191.35THz&gt;, 140362746465920)], 4:
[], 5: [], 6: [(&lt;ch2:191.40THz&gt;, 140362746465728)], None:
[(&lt;ch1:191.35THz&gt;, 140362746465920), (&lt;ch2:191.40THz&gt;,
140362746465728), (&lt;ch1:191.35THz&gt;, 140362746797456),
(&lt;ch2:191.40THz&gt;, 140362746794720)]}
t1 Inputs:
{1: [(&lt;ch1:191.35THz&gt;, 140362746797456), (&lt;ch1:191.35THz&gt;,
140362746797456)], 2: [(&lt;ch2:191.40THz&gt;, 140362746794720)], -1:
[(&lt;ch1:191.35THz&gt;, 140362746465920), (&lt;ch2:191.40THz&gt;,
140362746465728)]}
t1 Outputs:
{1: [(&lt;ch1:191.35THz&gt;, &lt;ch1:191.35THz&gt;)], 2: [(&lt;ch2:191.40THz&gt;,
&lt;ch2:191.40THz&gt;)]}
t2 Inputs:
{1: [(&lt;ch1:191.35THz&gt;, 140362746465920)], 2: [], -1:
[(&lt;ch1:191.35THz&gt;, 140362746797456), (&lt;ch2:191.40THz&gt;,
140362746797360)]}
t2 Outputs:
{1: [(&lt;ch1:191.35THz&gt;, &lt;ch1:191.35THz&gt;)], 2: [(&lt;ch2:191.40THz&gt;,
&lt;ch2:191.40THz&gt;)]}
t3 Inputs:
{1: [], 2: [(&lt;ch2:191.40THz&gt;, 140362746465728)], -1:
[(&lt;ch1:191.35THz&gt;, 140362746797312), (&lt;ch2:191.40THz&gt;,
140362746794720)]}
t3 Outputs:
{1: [(&lt;ch1:191.35THz&gt;, &lt;ch1:191.35THz&gt;)], 2: [(&lt;ch2:191.40THz&gt;,
&lt;ch2:191.40THz&gt;)]}
</pre></div>
</div>
<p>(Note: You should also see <code class="docutils literal notranslate"><span class="pre">osnr</span></code> at all of them, but for some reason that
doesn’t seem to be working properly at the moment. In my tests, it only
reports osnr for <code class="docutils literal notranslate"><span class="pre">t1</span></code> and <code class="docutils literal notranslate"><span class="pre">t2</span></code>:)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>mininet-optical&gt; osnr
&lt;name: t1-monitor, component: t1, mode: in&gt;:
&lt;ch1:191.35THz&gt; OSNR: 34.05 dB gOSNR: 15.99 dB
&lt;name: t2-monitor, component: t2, mode: in&gt;:
&lt;ch1:191.35THz&gt; OSNR: 34.11 dB gOSNR: 34.11 dB
&lt;name: t3-monitor, component: t3, mode: in&gt;:
</pre></div>
</div>
<p>You should also be able to monitor the OSNR remotely using REST calls:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>*** Monitoring signals at endpoints
* t1
{&quot;osnr&quot;: {&quot;1&quot;: {&quot;freq&quot;: 191350000000000.0, &quot;osnr&quot;:
34.04688966097812, &quot;gosnr&quot;: 15.985167480783709, &quot;power&quot;:
63.095734448019336, &quot;ase&quot;: 0.02484912117567492, &quot;nli&quot;:
4.00759355581639}}}* t2
{&quot;osnr&quot;: {&quot;1&quot;: {&quot;freq&quot;: 191350000000000.0, &quot;osnr&quot;:
34.11343356995615, &quot;gosnr&quot;: 34.11227284182009, &quot;power&quot;:
0.9999493444109917, &quot;ase&quot;: 0.00038782396576497437, &quot;nli&quot;:
2.653865120449501e-07}}}* t3
{&quot;osnr&quot;: {}}
</pre></div>
</div>
<p>(Hopefully we will be able to determine why there is no OSNR reported for
<code class="docutils literal notranslate"><span class="pre">t3</span></code>.)</p>
<p>This concludes the exercise!!</p>
<p><strong>Thanks for trying this out – we look forward to your feedback.</strong></p>
</section>
<section id="hints-and-advice">
<h3>Hints and Advice<a class="headerlink" href="#hints-and-advice" title="Permalink to this heading">¶</a></h3>
<ol class="arabic">
<li><p>Read the <a class="reference internal" href="api-overview.html"><span class="doc">API Overview</span></a></p>
<p>This provides an overview of Mininet-Optical’s Python API as well
as the REST control API.</p>
</li>
<li><p>Pay attention to port numbers</p>
<p>It’s tricky (if not maddeningly so) to get this (and many SDN
designs) working because you need to know the exact port numbers. You
may wish to try things like:</p>
<ul class="simple">
<li><p>Plotting (e.g. using <code class="docutils literal notranslate"><span class="pre">plotNet()</span></code>) and printing out (or drawing)
the topology and port numbers</p></li>
<li><p><em>Writing a helper function</em> to help you determine port numbers, for
example telling you what is (or should be) connected at the other
side of a particular node and port number, or telling you what <code class="docutils literal notranslate"><span class="pre">ROADM</span></code>
port should correspond to what <code class="docutils literal notranslate"><span class="pre">Terminal</span></code> port for a given <code class="docutils literal notranslate"><span class="pre">Terminal</span></code>
and transceiver, or even just dumping out what each node and port
number is connected to.</p></li>
<li><p>Possibly using <code class="docutils literal notranslate"><span class="pre">net.linksBetween(node1,</span> <span class="pre">node2)</span></code>, which returns all of
the links (as link objects) between two nodes in the Mininet
network. A link’s endpoints are <code class="docutils literal notranslate"><span class="pre">link.intf1</span></code> and <code class="docutils literal notranslate"><span class="pre">link.intf2</span></code>.</p></li>
<li><p>Logging port numbers/names to make sure they are what you think they
are</p></li>
</ul>
</li>
<li><p>Testing REST calls using <code class="docutils literal notranslate"><span class="pre">curl</span></code></p>
<p>REST calls can easily be executed and tested from the shell prompt using
<code class="docutils literal notranslate"><span class="pre">curl</span></code>, but remember to enclose the URLs in quotes to avoid the shell
(mis)interpreting special characters like &amp;. Note that shell variables
(<code class="docutils literal notranslate"><span class="pre">$url</span></code>) should be enclosed in double quotes (not single quotes!) in
order to be dereferenced.</p>
</li>
<li><p>Making mistakes is OK in an emulator, but be careful with hardware</p>
<p>Fortunately, if you make mistakes on a software emulator it has few
negative consequences, but mistakes in a hardware optical network, such
as creating an amplified laser feedback loop, could potentially have
disastrous consequences resulting in damaged devices at the very least!
Ideally devices will have failsafe mechanisms but this may not be
guaranteed.</p>
<p>Creating packet loops in Ethernet networks doesn’t usually cause fires
but usually results in an unusable network.</p>
</li>
</ol>
</section>
<section id="extra-credit-for-the-insanely-motivated">
<h3>Extra Credit for the Insanely Motivated<a class="headerlink" href="#extra-credit-for-the-insanely-motivated" title="Permalink to this heading">¶</a></h3>
<p>This is almost certainly more than enough for now, but here are some
(extremely optional) additional projects you could think about trying if
you are excessively enthusiastic and have lots of extra time:</p>
<ol class="arabic">
<li><p>Try passing <code class="docutils literal notranslate"><span class="pre">switch=functools.partial(OVSBridge,stp=True)</span></code> into the
<code class="docutils literal notranslate"><span class="pre">Mininet()</span></code> constructor call (you will need to <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">functools</span></code>) to
turn on <strong>spanning tree</strong>. Note that it can take a while (~30s) for
spanning tree to do its thing (specifically discover any loops and
block ports that create loops) but eventually you should be able to
ping everything. Now, try creating a full mesh/loop topology where
every terminal can connect to every other terminal. Verify that
spanning tree enables your (bridged L2 Ethernet) network to work
even in the presence of loops.</p>
<p>As an alternative to spanning tree, you could also use a packet SDN
controller such as ONOS that supports Ethernet topologies with
loops.</p>
</li>
<li><p>Create a <strong>ring network</strong> similar to the network from Part 1. See if
you can replicate the same (or similar) behavior. Note that the
emulator API that we are using for this tutorial is bidirectional,
so ROADM rules (for example) create paths in both directions.
Compare the OSNR and gOSNR values from simulation and emulation
(they should match if the paths are the same!)</p></li>
<li><p>Try using the fakecontroller.py framework to (re)write your
<strong>controller script in Python</strong>.</p></li>
<li><p>Create a <strong>3x3 grid/mesh network</strong> of 9 POPs (Points Of Presence,
i.e. uplink/downlink locations) with 9 transceivers per Terminal in
each POP. Use Manhattan routing to enable full mesh connectivity
without creating loops and while minimizing the number of signals
per link. Since this is an L2 Ethernet network, the connectivity
among your packet switches (Ethernet bridges) should be a tree, or
you should turn on spanning tree protocol for <code class="docutils literal notranslate"><span class="pre">OVSBridge</span></code> as described
in (1) above.</p></li>
<li><p>Take a look at <code class="docutils literal notranslate"><span class="pre">LinearRoadmTopo</span></code> and <code class="docutils literal notranslate"><span class="pre">DemoTopo</span></code> in <code class="docutils literal notranslate"><span class="pre">ofcdemo/demolib.py</span></code> as
well as the scripts that use them, simpledemo.py and demo.py, and
the apsp.py test controller. Unlike our simple exercises above,
these install <strong>IP routing rules</strong> (programmed with OpenFlow) as
well as multiple subnets to enable mesh connectivity. Can you create
a mesh network with multiple subnets and a controller that
implements a more advanced lightpath planning and routing
algorithm?</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">ofcdemo.demolib.configureLinearNet()</span></code> also uses OpenFlow to
set up IP routing rules. Alternately, you could use Mininet’s
<code class="docutils literal notranslate"><span class="pre">LinuxRouter</span></code> and install rules in the routers using Linux routing
commands.</p>
</li>
<li><p>Try creating a <strong>simplified text format</strong> to describe a
topology**,** and then create a <code class="docutils literal notranslate"><span class="pre">build()</span></code> method that reads your
description format and makes the appropriate calls to create the
topology.</p>
<p>For example, the following format could be used to specify something
like our simple linear network:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>h1 -- s1 -- t1 --25km- amp1 --25km-- t2 -- s2 -- h2
</pre></div>
</div>
<p>and this format could be used to specify a single ROADM network:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>h1 -- s1 -- t1 --25km- r1 --25km-- t2 -- s2 -- h1
r1 -- t3 -- s3 - h3
</pre></div>
</div>
<p>You could also use another format such as dot, or anything you
like.</p>
<p>Some questions to think about:</p>
<p>a.  How do you know the device type of a node in this specification?</p>
<p>b.  How do you know whether a link is a packet link or an optical
link?</p>
<p>c.  How are the port numbers assigned?</p>
<p>d.  How do we handle the other optical network device parameters?
Can we choose reasonable defaults? If so, what should they be?
Can we configure them in the controller? If so, how?</p>
<p>e.  How do you decide how many transceivers are included in a
terminal?</p>
<p>f.  What are the advantages and disadvantages of specifying your
topology in Python or in this simplified text format?</p>
</li>
</ol>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Mininet-Optical</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="README.html">Welcome to Mininet-Optical</a></li>
<li class="toctree-l1"><a class="reference internal" href="walkthrough.html">Installation and Walkthrough</a></li>
<li class="toctree-l1"><a class="reference internal" href="architecture.html">Architecture Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="api-overview.html">API Overview</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#simulation-mode-tutorial">Simulation Mode Tutorial</a></li>
<li class="toctree-l2"><a class="reference internal" href="#emulation-tutorial">Emulation Tutorial</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="visualization.html">Visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="autoapi/index.html">API Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="api-overview.html" title="previous chapter">API Overview</a></li>
      <li>Next: <a href="visualization.html" title="next chapter">Visualization</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Mininet-Optical Project Contributors.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/tutorial.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>